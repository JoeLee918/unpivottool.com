<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="canonical" href="https://unpivottool.com/excel-tools/cell-fill">
    
    <!-- SEO Meta Tags -->
    <title>Free Cell Fill Tool - Auto Fill Empty Cells in Excel Instantly</title>
    <meta name="description" content="Automatically fill blank cells in Excel after unmerging. Free cell fill tool detects empty cells and fills them with appropriate values. No manual filling required.">
    <meta name="keywords" content="cell fill tool, fill empty cells, excel blank cells, unmerge cells fill, auto fill blanks, excel cell filler, merge cells fix">
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Free Cell Fill Tool - Auto Fill Empty Cells in Excel">
    <meta property="og:description" content="Fix blank cells after unmerging in Excel. Automatically fill empty cells with correct values in seconds.">
    <meta property="og:url" content="https://unpivottool.com/excel-tools/cell-fill">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "Cell Fill Tool - Auto Fill Excel Blanks",
      "description": "Automatically fill blank cells in Excel tables after unmerging. Smart detection and filling of empty cells.",
      "url": "https://unpivottool.com/excel-tools/cell-fill",
      "applicationCategory": "BusinessApplication",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
    </script>
    
    <style>
        /* Base styles matching the original design */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 0;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        }

        .nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-brand {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .nav-info {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: #666;
        }

        .nav-links {
            display: flex;
            gap: 2rem;
            list-style: none;
        }

        .nav-links a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
            transition: color 0.3s;
        }

        .nav-links a:hover {
            color: #667eea;
        }

        /* Hero Section */
        .hero {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            padding: 4rem 0;
            text-align: center;
            color: white;
        }

        .hero h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .hero-subtitle {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.9;
        }

        .hero-features {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .hero-features span {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.5rem 1rem;
            border-radius: 25px;
            font-size: 0.9rem;
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        .btn-success {
            background: #48bb78;
            color: white;
        }

        .btn-success:hover {
            background: #38a169;
        }

        .btn-outline {
            background: transparent;
            border: 2px solid #667eea;
            color: #667eea;
        }

        .btn-outline:hover {
            background: #667eea;
            color: white;
        }

        .btn-large {
            padding: 1rem 2rem;
            font-size: 1.1rem;
        }

        /* Main Content */
        .main {
            background: white;
            min-height: 80vh;
            padding: 2rem 0;
        }

        .tool-section {
            margin-bottom: 3rem;
            padding: 2rem;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .tool-section h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.8rem;
        }

        .step-description {
            color: #666;
            margin-bottom: 2rem;
            font-size: 1.1rem;
        }

        /* Method Tabs */
        .method-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid #e2e8f0;
        }

        .tab-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            background: transparent;
            color: #4a5568;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-btn:hover {
            color: #667eea;
        }

        /* Input Methods */
        .input-method {
            display: none;
        }

        .input-method.active {
            display: block;
        }

        /* Table Styles */
        .table-container {
            overflow-x: auto;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        td {
            border: 1px solid #e2e8f0;
            padding: 8px 12px;
            min-height: 36px;
            position: relative;
        }

        td:focus {
            outline: 2px solid #667eea;
            outline-offset: -2px;
        }

        td[contenteditable="true"]:empty::before {
            content: " ";
            white-space: pre;
        }

        /* Upload Area */
        .upload-zone {
            border: 3px dashed #cbd5e0;
            border-radius: 12px;
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f7fafc;
        }

        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: #667eea;
            background: #edf2f7;
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        /* Fill Options */
        .fill-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .option-card {
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .option-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        .option-card.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option-card h3 {
            margin-bottom: 0.5rem;
            color: #2d3748;
        }

        .option-card p {
            color: #666;
            font-size: 0.9rem;
        }

        /* Settings Panel */
        .settings-panel {
            background: #f7fafc;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 2rem;
        }

        .settings-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .settings-row:last-child {
            margin-bottom: 0;
        }

        .settings-row label {
            min-width: 120px;
            font-weight: 500;
        }

        .settings-row select,
        .settings-row input {
            padding: 0.5rem;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        /* Preview Section */
        .preview-section {
            margin-top: 2rem;
            padding: 1.5rem;
            background: #f7fafc;
            border-radius: 8px;
        }

        .preview-section h3 {
            margin-bottom: 1rem;
            color: #2d3748;
        }

        .preview-table {
            max-height: 300px;
            overflow: auto;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
        }

        .preview-table table {
            font-size: 0.9rem;
        }

        .preview-table td {
            padding: 4px 8px;
        }

        /* Results Section */
        .results-section {
            margin-top: 2rem;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .results-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .results-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Alerts */
        .alert {
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-weight: 500;
        }

        .alert-success {
            background: #c6f6d5;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }

        .alert-error {
            background: #fed7d7;
            color: #c53030;
            border: 1px solid #fc8181;
        }

        .alert-warning {
            background: #fef5e7;
            color: #dd6b20;
            border: 1px solid #f6ad55;
        }

        .alert-info {
            background: #bee3f8;
            color: #2b6cb0;
            border: 1px solid #90cdf4;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-body {
            padding: 2rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .modal-footer {
            padding: 1.5rem 2rem;
            border-top: 1px solid #e2e8f0;
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2rem;
            }

            .hero-features {
                flex-direction: column;
                gap: 1rem;
            }

            .nav-info {
                display: none;
            }

            .fill-options {
                grid-template-columns: 1fr;
            }

            .results-header {
                flex-direction: column;
                align-items: stretch;
            }

            .results-actions {
                justify-content: center;
            }
        }

        /* Special styling for empty cells visualization */
        .empty-cell {
            background: #fff5f5 !important;
            position: relative;
        }

        .empty-cell::after {
            content: "Empty";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e53e3e;
            font-size: 0.7rem;
            font-style: italic;
            opacity: 0.7;
        }

        .filled-cell {
            background: #f0fff4 !important;
            animation: fillAnimation 0.3s ease-in-out;
        }

        @keyframes fillAnimation {
            from {
                background: #fff5f5;
            }
            to {
                background: #f0fff4;
            }
        }

        /* Progress indicator */
        .progress-indicator {
            margin: 1rem 0;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            height: 8px;
            display: none;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        /* Stats display */
        .fill-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .stat-card {
            text-align: center;
            padding: 1rem;
            background: #f7fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #666;
            margin-top: 0.25rem;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <nav class="nav">
                <div class="nav-brand">🔧 Cell Fill Tool</div>
                <ul class="nav-links">
                    <li><a href="/">← Back to Unpivot Tool</a></li>
                    <li><a href="/excel-tools/">All Tools</a></li>
                </ul>
                <div class="nav-info">
                    <span>✅ 100% Free</span>
                    <span>✅ Local Processing</span>
                    <span>✅ No Signup</span>
                </div>
            </nav>
        </div>
    </header>

    <!-- Hero Section -->
    <section class="hero">
        <div class="container">
            <h1>Auto Fill Empty Cells After Unmerging</h1>
            <p class="hero-subtitle">Smart detection and filling of blank cells in Excel tables. Perfect for fixing data after unmerging cells or cleaning imported data.</p>
            <div class="hero-features">
                <span>🎯 Smart Fill Detection</span>
                <span>⚡ Instant Processing</span>
                <span>🔒 Local Processing Only</span>
                <span>📊 Multiple Fill Methods</span>
            </div>
        </div>
    </section>

    <!-- Main Tool -->
    <main class="main">
        <div class="container">
            <!-- Step 1: Input -->
            <section id="step1" class="tool-section">
                <h2>Step 1: Upload Your Data with Empty Cells</h2>
                <p class="step-description">📋 Upload or paste your Excel data that has empty cells needing to be filled</p>
                
                <!-- Method Selection -->
                <div class="method-tabs">
                    <button class="tab-btn active" data-method="paste">📋 Paste Data</button>
                    <button class="tab-btn" data-method="upload">📁 Upload File</button>
                </div>

                <!-- Paste Method -->
                <div class="input-method active" data-method="paste">
                    <div class="paste-area">
                        <p class="paste-instruction">Paste your data with empty cells here (example data shows typical unmerged cell scenario):</p>
                        <div class="table-container">
                            <table id="data-grid" contenteditable="true">
                                <tr>
                                    <td>Department</td>
                                    <td>Employee</td>
                                    <td>Position</td>
                                    <td>Salary</td>
                                </tr>
                                <tr>
                                    <td>Sales</td>
                                    <td>John Smith</td>
                                    <td>Manager</td>
                                    <td>75000</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td>Sarah Wilson</td>
                                    <td>Associate</td>
                                    <td>45000</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td>Mike Johnson</td>
                                    <td>Associate</td>
                                    <td>47000</td>
                                </tr>
                                <tr>
                                    <td>Marketing</td>
                                    <td>Lisa Brown</td>
                                    <td>Director</td>
                                    <td>85000</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td>Tom Davis</td>
                                    <td>Specialist</td>
                                    <td>52000</td>
                                </tr>
                                <tr>
                                    <td>IT</td>
                                    <td>Alex Chen</td>
                                    <td>Developer</td>
                                    <td>72000</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <td>Emma Garcia</td>
                                    <td>Developer</td>
                                    <td>69000</td>
                                </tr>
                            </table>
                        </div>
                        <div style="margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button id="expand-editor" class="btn btn-secondary">🔍 Expand Full Editor</button>
                            <button id="clear-data" class="btn btn-secondary">🗑️ Clear All</button>
                            <button id="add-row" class="btn btn-secondary">➕ Add Row</button>
                            <button id="add-column" class="btn btn-secondary">➕ Add Column</button>
                        </div>
                    </div>
                </div>

                <!-- Upload Method -->
                <div class="input-method" data-method="upload">
                    <div class="upload-area">
                        <div class="upload-zone" id="upload-zone">
                            <div class="upload-icon">📁</div>
                            <p><strong>Drop your Excel file here or click to browse</strong></p>
                            <p>🔒 Files processed locally - never uploaded to servers</p>
                            <p class="upload-formats">Supports: Excel (.xlsx, .xls) and CSV files up to 5MB</p>
                            <input type="file" id="file-input" accept=".xlsx,.xls,.csv" hidden>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Step 2: Configuration -->
            <section class="tool-section">
                <h2>Step 2: Choose Your Fill Method</h2>
                <p class="step-description">🎯 Select how you want to fill the empty cells</p>
                
                <div class="fill-options">
                    <div class="option-card selected" data-method="down-fill">
                        <h3>🔽 Fill Down (Recommended)</h3>
                        <p>Fill empty cells with the value from the cell above. Perfect for categories and merged cell data.</p>
                    </div>
                    <div class="option-card" data-method="up-fill">
                        <h3>🔼 Fill Up</h3>
                        <p>Fill empty cells with the value from the cell below. Useful for bottom-to-top data structures.</p>
                    </div>
                    <div class="option-card" data-method="left-fill">
                        <h3>◀️ Fill Left</h3>
                        <p>Fill empty cells with the value from the cell to the left. Good for horizontal data patterns.</p>
                    </div>
                    <div class="option-card" data-method="right-fill">
                        <h3>▶️ Fill Right</h3>
                        <p>Fill empty cells with the value from the cell to the right. Useful for right-to-left patterns.</p>
                    </div>
                    <div class="option-card" data-method="custom-fill">
                        <h3>✏️ Custom Value</h3>
                        <p>Fill all empty cells with a specific value you provide. Great for placeholders or default values.</p>
                    </div>
                    <div class="option-card" data-method="smart-fill">
                        <h3>🧠 Smart Fill</h3>
                        <p>Intelligent detection: fills down for text, interpolates for numbers. Best of both worlds.</p>
                    </div>
                </div>

                <!-- Settings Panel -->
                <div class="settings-panel">
                    <h3>Fill Settings</h3>
                    <div class="settings-row">
                        <label>Apply to columns:</label>
                        <select id="column-selector">
                            <option value="all">All columns</option>
                            <option value="selected">Selected columns only</option>
                        </select>
                    </div>
                    <div class="settings-row" id="custom-value-row" style="display: none;">
                        <label>Custom value:</label>
                        <input type="text" id="custom-value" placeholder="Enter value to fill empty cells">
                    </div>
                    <div class="settings-row">
                        <label>Skip header row:</label>
                        <input type="checkbox" id="skip-header" checked>
                    </div>
                    <div class="settings-row">
                        <label>Preview before apply:</label>
                        <input type="checkbox" id="show-preview" checked>
                    </div>
                </div>

                <div style="text-align: center; margin-top: 2rem;">
                    <button id="analyze-btn" class="btn btn-secondary" style="margin-right: 1rem;">🔍 Analyze Empty Cells</button>
                    <button id="preview-btn" class="btn btn-outline" style="margin-right: 1rem;">👀 Preview Changes</button>
                    <button id="fill-btn" class="btn btn-primary">🔧 Fill Empty Cells</button>
                </div>
            </section>

            <!-- Analysis Results -->
            <section class="tool-section" id="analysis-section" style="display: none;">
                <h2>📊 Empty Cell Analysis</h2>
                <div class="fill-stats" id="fill-stats">
                    <!-- Stats will be populated here -->
                </div>
                <div class="progress-indicator" id="progress-indicator">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
            </section>

            <!-- Preview Section -->
            <section class="preview-section" id="preview-section" style="display: none;">
                <h3>👀 Preview Changes</h3>
                <p>Green cells show what will be filled. Review before applying:</p>
                <div class="preview-table" id="preview-table">
                    <!-- Preview table will be populated here -->
                </div>
                <div style="margin-top: 1rem; text-align: center;">
                    <button id="apply-changes-btn" class="btn btn-success">✅ Apply These Changes</button>
                    <button id="cancel-preview-btn" class="btn btn-secondary">❌ Cancel</button>
                </div>
            </section>

            <!-- Results Section -->
            <section class="results-section" id="results-section" style="display: none;">
                <h2>✅ Cells Successfully Filled</h2>
                <div class="results-header">
                    <div class="results-info">
                        <span id="results-count">0 cells filled</span>
                        <span class="time-saved">⚡ Saved hours of manual work!</span>
                    </div>
                    <div class="results-actions">
                        <button id="edit-results" class="btn btn-secondary">✏️ Edit Results</button>
                        <button id="copy-results" class="btn btn-secondary">📋 Copy All</button>
                        <button id="download-excel" class="btn btn-success">📊 Download Excel</button>
                        <button id="download-csv" class="btn btn-secondary">📄 Download CSV</button>
                    </div>
                </div>
                
                <div class="table-container">
                    <table id="results-table">
                        <!-- Results will be populated here -->
                    </table>
                </div>
            </section>
        </div>
    </main>

    <!-- Modal Editor -->
    <div id="modal-editor" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Full Table Editor</h3>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <div id="large-grid-container" class="large-grid-container">
                    <!-- Large editable grid will be populated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button id="save-changes" class="btn btn-primary">Save Changes</button>
                <button class="btn btn-secondary modal-close">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    
    <script>
        class CellFiller {
            constructor() {
                this.data = [];
                this.originalData = [];
                this.previewData = [];
                this.fillMethod = 'down-fill';
                this.customValue = '';
                this.skipHeader = true;
                this.selectedColumns = 'all';
                
                this.initializeEventListeners();
                this.loadSampleData();
            }

            initializeEventListeners() {
                // Tab switching
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.switchInputMethod(e.target.dataset.method));
                });

                // File upload
                const uploadZone = document.getElementById('upload-zone');
                const fileInput = document.getElementById('file-input');
                
                uploadZone.addEventListener('click', () => fileInput.click());
                uploadZone.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadZone.addEventListener('drop', this.handleFileDrop.bind(this));
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));

                // Table editing
                const dataGrid = document.getElementById('data-grid');
                dataGrid.addEventListener('input', this.handleTableEdit.bind(this));
                dataGrid.addEventListener('paste', this.handlePaste.bind(this));

                // Fill method selection
                document.querySelectorAll('.option-card').forEach(card => {
                    card.addEventListener('click', () => this.selectFillMethod(card.dataset.method));
                });

                // Settings
                document.getElementById('column-selector').addEventListener('change', (e) => {
                    this.selectedColumns = e.target.value;
                });

                document.getElementById('custom-value').addEventListener('input', (e) => {
                    this.customValue = e.target.value;
                });

                document.getElementById('skip-header').addEventListener('change', (e) => {
                    this.skipHeader = e.target.checked;
                });

                // Action buttons
                document.getElementById('analyze-btn').addEventListener('click', this.analyzeEmptyCells.bind(this));
                document.getElementById('preview-btn').addEventListener('click', this.previewChanges.bind(this));
                document.getElementById('fill-btn').addEventListener('click', this.fillCells.bind(this));
                document.getElementById('apply-changes-btn').addEventListener('click', this.applyChanges.bind(this));
                document.getElementById('cancel-preview-btn').addEventListener('click', this.cancelPreview.bind(this));

                // Data management
                document.getElementById('clear-data').addEventListener('click', this.clearData.bind(this));
                document.getElementById('add-row').addEventListener('click', this.addRow.bind(this));
                document.getElementById('add-column').addEventListener('click', this.addColumn.bind(this));
                document.getElementById('expand-editor').addEventListener('click', this.openExpandedEditor.bind(this));

                // Results actions
                document.getElementById('edit-results').addEventListener('click', this.editResults.bind(this));
                document.getElementById('copy-results').addEventListener('click', this.copyResults.bind(this));
                document.getElementById('download-excel').addEventListener('click', this.downloadExcel.bind(this));
                document.getElementById('download-csv').addEventListener('click', this.downloadCSV.bind(this));

                // Modal controls
                document.querySelectorAll('.modal-close').forEach(btn => {
                    btn.addEventListener('click', this.closeModal.bind(this));
                });
                document.getElementById('save-changes').addEventListener('click', this.saveModalChanges.bind(this));
            }

            switchInputMethod(method) {
                // Update active tab
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-method="${method}"]`).classList.add('active');

                // Show corresponding method
                document.querySelectorAll('.input-method').forEach(methodEl => {
                    methodEl.classList.remove('active');
                });
                document.querySelector(`.input-method[data-method="${method}"]`).classList.add('active');
            }

            loadSampleData() {
                this.extractTableData();
            }

            extractTableData() {
                const grid = document.getElementById('data-grid');
                const rows = grid.querySelectorAll('tr');
                
                this.data = [];
                rows.forEach((row) => {
                    const cells = row.querySelectorAll('td');
                    const rowData = [];
                    
                    cells.forEach((cell) => {
                        rowData.push(cell.textContent.trim());
                    });
                    
                    this.data.push(rowData);
                });

                this.originalData = JSON.parse(JSON.stringify(this.data));
            }

            selectFillMethod(method) {
                this.fillMethod = method;
                
                // Update visual selection
                document.querySelectorAll('.option-card').forEach(card => {
                    card.classList.remove('selected');
                });
                document.querySelector(`[data-method="${method}"]`).classList.add('selected');

                // Show/hide custom value input
                const customValueRow = document.getElementById('custom-value-row');
                if (method === 'custom-fill') {
                    customValueRow.style.display = 'flex';
                } else {
                    customValueRow.style.display = 'none';
                }
            }

            analyzeEmptyCells() {
                this.extractTableData();
                
                if (this.data.length === 0) {
                    this.showAlert('No data to analyze. Please add your data first.', 'error');
                    return;
                }

                let totalCells = 0;
                let emptyCells = 0;
                const columnStats = {};

                this.data.forEach((row, rowIndex) => {
                    if (this.skipHeader && rowIndex === 0) return;
                    
                    row.forEach((cell, colIndex) => {
                        totalCells++;
                        
                        if (!columnStats[colIndex]) {
                            columnStats[colIndex] = { total: 0, empty: 0, name: this.data[0][colIndex] || `Column ${colIndex + 1}` };
                        }
                        columnStats[colIndex].total++;
                        
                        if (this.isEmpty(cell)) {
                            emptyCells++;
                            columnStats[colIndex].empty++;
                        }
                    });
                });

                // Display stats
                const statsHtml = `
                    <div class="stat-card">
                        <div class="stat-number">${totalCells}</div>
                        <div class="stat-label">Total Cells</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${emptyCells}</div>
                        <div class="stat-label">Empty Cells</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${Math.round((emptyCells / totalCells) * 100)}%</div>
                        <div class="stat-label">Needs Filling</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${Object.keys(columnStats).length}</div>
                        <div class="stat-label">Columns</div>
                    </div>
                `;

                document.getElementById('fill-stats').innerHTML = statsHtml;
                document.getElementById('analysis-section').style.display = 'block';

                this.showAlert(`Analysis complete: ${emptyCells} empty cells found out of ${totalCells} total cells.`, 'info');
            }

            previewChanges() {
                this.extractTableData();
                
                if (this.data.length === 0) {
                    this.showAlert('No data to preview. Please add your data first.', 'error');
                    return;
                }

                // Create preview data
                this.previewData = this.processDataFill(JSON.parse(JSON.stringify(this.data)));
                
                // Generate preview table HTML
                let html = '<table>';
                this.previewData.forEach((row, rowIndex) => {
                    html += '<tr>';
                    row.forEach((cell, colIndex) => {
                        const originalCell = this.data[rowIndex][colIndex];
                        const isChanged = this.isEmpty(originalCell) && !this.isEmpty(cell);
                        const cellClass = isChanged ? 'filled-cell' : '';
                        
                        html += `<td class="${cellClass}">${cell || ''}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</table>';

                document.getElementById('preview-table').innerHTML = html;
                document.getElementById('preview-section').style.display = 'block';

                // Scroll to preview
                document.getElementById('preview-section').scrollIntoView({ behavior: 'smooth' });
            }

            fillCells() {
                if (document.getElementById('show-preview').checked) {
                    this.previewChanges();
                } else {
                    this.applyChanges();
                }
            }

            applyChanges() {
                this.extractTableData();
                
                if (this.data.length === 0) {
                    this.showAlert('No data to process. Please add your data first.', 'error');
                    return;
                }

                // Process the data
                const filledData = this.processDataFill(JSON.parse(JSON.stringify(this.data)));
                
                // Count changes
                let changeCount = 0;
                this.data.forEach((row, rowIndex) => {
                    row.forEach((cell, colIndex) => {
                        if (this.isEmpty(cell) && !this.isEmpty(filledData[rowIndex][colIndex])) {
                            changeCount++;
                        }
                    });
                });

                // Update the data and display
                this.data = filledData;
                this.updateTableDisplay();
                this.displayResults(changeCount);
                
                // Hide preview section
                document.getElementById('preview-section').style.display = 'none';
                
                this.showAlert(`Successfully filled ${changeCount} empty cells!`, 'success');
            }

            processDataFill(data) {
                if (data.length === 0) return data;

                const startRow = this.skipHeader ? 1 : 0;
                const result = JSON.parse(JSON.stringify(data));

                switch (this.fillMethod) {
                    case 'down-fill':
                        return this.fillDown(result, startRow);
                    case 'up-fill':
                        return this.fillUp(result, startRow);
                    case 'left-fill':
                        return this.fillLeft(result, startRow);
                    case 'right-fill':
                        return this.fillRight(result, startRow);
                    case 'custom-fill':
                        return this.fillCustom(result, startRow);
                    case 'smart-fill':
                        return this.fillSmart(result, startRow);
                    default:
                        return this.fillDown(result, startRow);
                }
            }

            fillDown(data, startRow) {
                for (let colIndex = 0; colIndex < data[0].length; colIndex++) {
                    let lastValidValue = '';
                    
                    for (let rowIndex = startRow; rowIndex < data.length; rowIndex++) {
                        const currentValue = data[rowIndex][colIndex];
                        
                        if (this.isEmpty(currentValue)) {
                            if (lastValidValue !== '') {
                                data[rowIndex][colIndex] = lastValidValue;
                            }
                        } else {
                            lastValidValue = currentValue;
                        }
                    }
                }
                return data;
            }

            fillUp(data, startRow) {
                for (let colIndex = 0; colIndex < data[0].length; colIndex++) {
                    let nextValidValue = '';
                    
                    // First pass: find next valid values
                    for (let rowIndex = data.length - 1; rowIndex >= startRow; rowIndex--) {
                        const currentValue = data[rowIndex][colIndex];
                        
                        if (!this.isEmpty(currentValue)) {
                            nextValidValue = currentValue;
                        } else if (nextValidValue !== '') {
                            data[rowIndex][colIndex] = nextValidValue;
                        }
                    }
                }
                return data;
            }

            fillLeft(data, startRow) {
                for (let rowIndex = startRow; rowIndex < data.length; rowIndex++) {
                    let lastValidValue = '';
                    
                    for (let colIndex = 0; colIndex < data[rowIndex].length; colIndex++) {
                        const currentValue = data[rowIndex][colIndex];
                        
                        if (this.isEmpty(currentValue)) {
                            if (lastValidValue !== '') {
                                data[rowIndex][colIndex] = lastValidValue;
                            }
                        } else {
                            lastValidValue = currentValue;
                        }
                    }
                }
                return data;
            }

            fillRight(data, startRow) {
                for (let rowIndex = startRow; rowIndex < data.length; rowIndex++) {
                    let nextValidValue = '';
                    
                    // First pass: find next valid values
                    for (let colIndex = data[rowIndex].length - 1; colIndex >= 0; colIndex--) {
                        const currentValue = data[rowIndex][colIndex];
                        
                        if (!this.isEmpty(currentValue)) {
                            nextValidValue = currentValue;
                        } else if (nextValidValue !== '') {
                            data[rowIndex][colIndex] = nextValidValue;
                        }
                    }
                }
                return data;
            }

            fillCustom(data, startRow) {
                if (!this.customValue) {
                    this.showAlert('Please enter a custom value to fill empty cells.', 'warning');
                    return data;
                }

                for (let rowIndex = startRow; rowIndex < data.length; rowIndex++) {
                    for (let colIndex = 0; colIndex < data[rowIndex].length; colIndex++) {
                        if (this.isEmpty(data[rowIndex][colIndex])) {
                            data[rowIndex][colIndex] = this.customValue;
                        }
                    }
                }
                return data;
            }

            fillSmart(data, startRow) {
                for (let colIndex = 0; colIndex < data[0].length; colIndex++) {
                    // Analyze column to determine if it's mostly numeric
                    const columnValues = [];
                    for (let rowIndex = startRow; rowIndex < data.length; rowIndex++) {
                        const value = data[rowIndex][colIndex];
                        if (!this.isEmpty(value)) {
                            columnValues.push(value);
                        }
                    }

                    const isNumericColumn = this.isNumericColumn(columnValues);
                    
                    if (isNumericColumn) {
                        // For numeric columns, try interpolation where possible
                        this.fillNumericColumn(data, colIndex, startRow);
                    } else {
                        // For text columns, fill down
                        this.fillTextColumn(data, colIndex, startRow);
                    }
                }
                return data;
            }

            isNumericColumn(values) {
                if (values.length === 0) return false;
                const numericCount = values.filter(val => !isNaN(parseFloat(val)) && isFinite(val)).length;
                return numericCount / values.length > 0.7; // 70% numeric threshold
            }

            fillNumericColumn(data, colIndex, startRow) {
                // Simple numeric fill down (could be enhanced with interpolation)
                let lastValidValue = '';
                
                for (let rowIndex = startRow; rowIndex < data.length; rowIndex++) {
                    const currentValue = data[rowIndex][colIndex];
                    
                    if (this.isEmpty(currentValue)) {
                        if (lastValidValue !== '') {
                            data[rowIndex][colIndex] = lastValidValue;
                        }
                    } else {
                        lastValidValue = currentValue;
                    }
                }
            }

            fillTextColumn(data, colIndex, startRow) {
                let lastValidValue = '';
                
                for (let rowIndex = startRow; rowIndex < data.length; rowIndex++) {
                    const currentValue = data[rowIndex][colIndex];
                    
                    if (this.isEmpty(currentValue)) {
                        if (lastValidValue !== '') {
                            data[rowIndex][colIndex] = lastValidValue;
                        }
                    } else {
                        lastValidValue = currentValue;
                    }
                }
            }

            isEmpty(value) {
                return value === null || 
                       value === undefined || 
                       value === '' || 
                       (typeof value === 'string' && value.trim() === '');
            }

            updateTableDisplay() {
                const grid = document.getElementById('data-grid');
                grid.innerHTML = '';

                this.data.forEach(row => {
                    const tr = document.createElement('tr');
                    row.forEach(cell => {
                        const td = document.createElement('td');
                        td.textContent = cell || '';
                        td.contentEditable = true;
                        tr.appendChild(td);
                    });
                    grid.appendChild(tr);
                });
            }

            displayResults(changeCount) {
                document.getElementById('results-count').textContent = `${changeCount} cells filled`;
                
                // Create results table
                let html = '<table>';
                this.data.forEach(row => {
                    html += '<tr>';
                    row.forEach(cell => {
                        html += `<td>${cell || ''}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</table>';

                document.getElementById('results-table').innerHTML = html;
                document.getElementById('results-section').style.display = 'block';

                // Scroll to results
                document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
            }

            cancelPreview() {
                document.getElementById('preview-section').style.display = 'none';
            }

            // File handling methods
            handleDragOver(e) {
                e.preventDefault();
                e.currentTarget.classList.add('dragover');
            }

            handleFileDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.processFile(files[0]);
                }
            }

            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }

            async processFile(file) {
                try {
                    let data;
                    const fileName = file.name.toLowerCase();
                    
                    if (fileName.endsWith('.csv')) {
                        data = await this.parseCSV(file);
                    } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                        data = await this.parseExcel(file);
                    } else {
                        this.showAlert('Unsupported file format. Please upload an Excel (.xlsx, .xls) or CSV file.', 'error');
                        return;
                    }

                    this.loadDataToGrid(data);
                    this.switchInputMethod('paste');
                    this.showAlert('File uploaded successfully!', 'success');
                } catch (error) {
                    console.error('File processing error:', error);
                    this.showAlert('Unable to process this file. Please check the format and try again.', 'error');
                }
            }

            parseCSV(file) {
                return new Promise((resolve, reject) => {
                    Papa.parse(file, {
                        complete: (results) => {
                            if (results.errors.length > 0) {
                                reject(new Error('CSV parsing failed'));
                            } else {
                                resolve(results.data);
                            }
                        },
                        error: reject
                    });
                });
            }

            parseExcel(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const sheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[sheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                            resolve(jsonData);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }

            loadDataToGrid(data) {
                const grid = document.getElementById('data-grid');
                grid.innerHTML = '';

                data.forEach(row => {
                    const tr = document.createElement('tr');
                    row.forEach(cell => {
                        const td = document.createElement('td');
                        td.textContent = cell || '';
                        td.contentEditable = true;
                        tr.appendChild(td);
                    });
                    grid.appendChild(tr);
                });
            }

            handleTableEdit() {
                setTimeout(() => {
                    this.extractTableData();
                }, 100);
            }

            handlePaste(e) {
                e.preventDefault();
                const paste = e.clipboardData.getData('text');
                
                if (paste) {
                    try {
                        const rows = this.parseClipboardData(paste);
                        this.loadDataToGrid(rows);
                        this.extractTableData();
                        this.showAlert('Data pasted successfully!', 'success');
                    } catch (error) {
                        this.showAlert('Failed to process pasted data. Please try again.', 'error');
                    }
                }
            }

            parseClipboardData(pasteData) {
                const normalizedData = pasteData.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim();
                
                if (normalizedData.includes('\t')) {
                    return normalizedData.split('\n').map(line => line.split('\t'));
                } else {
                    return normalizedData.split('\n').map(line => [line]);
                }
            }

            // Data management methods
            clearData() {
                if (confirm('Are you sure you want to clear all data? This action cannot be undone.')) {
                    const grid = document.getElementById('data-grid');
                    grid.innerHTML = '<tr><td></td><td></td><td></td></tr>';
                    this.extractTableData();
                    this.showAlert('Data cleared successfully!', 'success');
                }
            }

            addRow() {
                const grid = document.getElementById('data-grid');
                const lastRow = grid.querySelector('tr:last-child');
                const colCount = lastRow ? lastRow.children.length : 3;
                
                const newRow = document.createElement('tr');
                for (let i = 0; i < colCount; i++) {
                    const td = document.createElement('td');
                    td.contentEditable = true;
                    td.textContent = '';
                    newRow.appendChild(td);
                }
                
                grid.appendChild(newRow);
                this.extractTableData();
            }

            addColumn() {
                const grid = document.getElementById('data-grid');
                const rows = grid.querySelectorAll('tr');
                
                rows.forEach(row => {
                    const td = document.createElement('td');
                    td.contentEditable = true;
                    td.textContent = '';
                    row.appendChild(td);
                });
                
                this.extractTableData();
            }

            // Modal and results methods
            openExpandedEditor() {
                const modal = document.getElementById('modal-editor');
                const container = document.getElementById('large-grid-container');
                
                container.innerHTML = this.createLargeGrid();
                modal.style.display = 'flex';
            }

            createLargeGrid() {
                let html = '<table class="excel-grid" id="large-grid" contenteditable="true">';
                
                const data = this.data.length > 0 ? this.data : [['', '', ''], ['', '', ''], ['', '', '']];
                
                data.forEach(row => {
                    html += '<tr>';
                    row.forEach(cell => {
                        html += `<td tabindex="0">${cell || ''}</td>`;
                    });
                    html += '</tr>';
                });
                
                html += '</table>';
                return html;
            }

            saveModalChanges() {
                const largeGrid = document.getElementById('large-grid');
                const rows = largeGrid.querySelectorAll('tr');
                
                const newData = [];
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    const rowData = [];
                    cells.forEach(cell => {
                        rowData.push(cell.textContent.trim());
                    });
                    if (rowData.some(cell => cell !== '')) {
                        newData.push(rowData);
                    }
                });

                this.loadDataToGrid(newData);
                this.extractTableData();
                this.closeModal();
                this.showAlert('Changes saved successfully!', 'success');
            }

            closeModal() {
                const modal = document.getElementById('modal-editor');
                modal.style.display = 'none';
            }

            editResults() {
                this.openExpandedEditor();
            }

            async copyResults() {
                if (this.data.length === 0) {
                    this.showAlert('No data to copy. Please fill cells first.', 'warning');
                    return;
                }

                try {
                    let csvText = '';
                    this.data.forEach(row => {
                        csvText += row.join('\t') + '\n';
                    });

                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(csvText);
                    } else {
                        this.fallbackCopyToClipboard(csvText);
                    }

                    this.showAlert(`Successfully copied ${this.data.length} rows to clipboard!`, 'success');
                } catch (error) {
                    this.showAlert('Unable to copy to clipboard. Please try selecting and copying manually.', 'error');
                }
            }

            fallbackCopyToClipboard(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    textArea.remove();
                } catch (err) {
                    textArea.remove();
                    throw err;
                }
            }

            downloadExcel() {
                if (this.data.length === 0) {
                    this.showAlert('No data to download. Please fill cells first.', 'warning');
                    return;
                }

                try {
                    const ws = XLSX.utils.aoa_to_sheet(this.data);
                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, 'Filled Data');
                    
                    const filename = `cell_filled_data_${new Date().toISOString().slice(0, 10)}.xlsx`;
                    XLSX.writeFile(wb, filename);
                    
                    this.showAlert('Excel file downloaded successfully!', 'success');
                } catch (error) {
                    this.showAlert('Unable to download Excel file. Please try again.', 'error');
                }
            }

            downloadCSV() {
                if (this.data.length === 0) {
                    this.showAlert('No data to download. Please fill cells first.', 'warning');
                    return;
                }

                try {
                    const csv = Papa.unparse(this.data);
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    
                    const filename = `cell_filled_data_${new Date().toISOString().slice(0, 10)}.csv`;
                    link.href = URL.createObjectURL(blob);
                    link.download = filename;
                    link.click();
                    
                    this.showAlert('CSV file downloaded successfully!', 'success');
                } catch (error) {
                    this.showAlert('Unable to download CSV file. Please try again.', 'error');
                }
            }

            showAlert(message, type = 'info') {
                // Remove existing alerts
                const existingAlerts = document.querySelectorAll('.alert');
                existingAlerts.forEach(alert => alert.remove());

                // Create new alert
                const alert = document.createElement('div');
                alert.className = `alert alert-${type}`;
                alert.textContent = message;

                // Insert at top of main content
                const main = document.querySelector('.main .container');
                main.insertBefore(alert, main.firstChild);

                // Auto remove after 4 seconds
                setTimeout(() => {
                    alert.remove();
                }, 4000);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new CellFiller();
        });
    </script>
</body>
</html>